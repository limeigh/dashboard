import{T as M}from"./splaytree-0.0.0-dataease.js";import{o as T}from"./robust-predicates-0.0.0-dataease.js";const w=(l,t)=>l.ll.x<=t.x&&t.x<=l.ur.x&&l.ll.y<=t.y&&t.y<=l.ur.y,P=(l,t)=>{if(t.ur.x<l.ll.x||l.ur.x<t.ll.x||t.ur.y<l.ll.y||l.ur.y<t.ll.y)return null;const e=l.ll.x<t.ll.x?t.ll.x:l.ll.x,n=l.ur.x<t.ur.x?l.ur.x:t.ur.x,i=l.ll.y<t.ll.y?t.ll.y:l.ll.y,s=l.ur.y<t.ur.y?l.ur.y:t.ur.y;return{ll:{x:e,y:i},ur:{x:n,y:s}}};let m=Number.EPSILON;m===void 0&&(m=Math.pow(2,-52));const j=m*m,L=(l,t)=>{if(-m<l&&l<m&&-m<t&&t<m)return 0;const e=l-t;return e*e<j*l*t?0:l<t?-1:1};class F{constructor(){this.reset()}reset(){this.xRounder=new A,this.yRounder=new A}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}}class A{constructor(){this.tree=new M,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(n!==null&&L(e.key,n.key)===0)return this.tree.remove(t),n.key;const i=this.tree.next(e);return i!==null&&L(e.key,i.key)===0?(this.tree.remove(t),i.key):t}}const v=new F,b=(l,t)=>l.x*t.y-l.y*t.x,G=(l,t)=>l.x*t.x+l.y*t.y,O=(l,t,e)=>{const n=T(l.x,l.y,t.x,t.y,e.x,e.y);return n>0?-1:n<0?1:0},I=l=>Math.sqrt(G(l,l)),Y=(l,t,e)=>{const n={x:t.x-l.x,y:t.y-l.y},i={x:e.x-l.x,y:e.y-l.y};return b(i,n)/I(i)/I(n)},q=(l,t,e)=>{const n={x:t.x-l.x,y:t.y-l.y},i={x:e.x-l.x,y:e.y-l.y};return G(i,n)/I(i)/I(n)},_=(l,t,e)=>t.y===0?null:{x:l.x+t.x/t.y*(e-l.y),y:e},N=(l,t,e)=>t.x===0?null:{x:e,y:l.y+t.y/t.x*(e-l.x)},z=(l,t,e,n)=>{if(t.x===0)return N(e,n,l.x);if(n.x===0)return N(l,t,e.x);if(t.y===0)return _(e,n,l.y);if(n.y===0)return _(l,t,e.y);const i=b(t,n);if(i==0)return null;const s={x:e.x-l.x,y:e.y-l.y},h=b(s,t)/i,o=b(s,n)/i,u=l.x+o*t.x,c=e.x+h*n.x,x=l.y+o*t.y,r=e.y+h*n.y,f=(u+c)/2,p=(x+r)/2;return{x:f,y:p}};class a{static compare(t,e){const n=a.comparePoints(t.point,e.point);return n!==0?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:S.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){t.events===void 0?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let n=0,i=e.length;n<i;n++){const s=e[n];this.point.events.push(s),s.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(n.segment.consumedBy===void 0)for(let i=e+1;i<t;i++){const s=this.point.events[i];s.consumedBy===void 0&&n.otherSE.point.events===s.otherSE.point.events&&n.segment.consume(s.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const i=this.point.events[e];i!==this&&!i.segment.ringOut&&i.segment.isInResult()&&t.push(i)}return t}getLeftmostComparator(t){const e=new Map,n=i=>{const s=i.otherSE;e.set(i,{sine:Y(this.point,t.point,s.point),cosine:q(this.point,t.point,s.point)})};return(i,s)=>{e.has(i)||n(i),e.has(s)||n(s);const{sine:h,cosine:o}=e.get(i),{sine:u,cosine:c}=e.get(s);return h>=0&&u>=0?o<c?1:o>c?-1:0:h<0&&u<0?o<c?-1:o>c?1:0:u<h?-1:u>h?1:0}}}let U=0;class S{static compare(t,e){const n=t.leftSE.point.x,i=e.leftSE.point.x,s=t.rightSE.point.x,h=e.rightSE.point.x;if(h<n)return 1;if(s<i)return-1;const o=t.leftSE.point.y,u=e.leftSE.point.y,c=t.rightSE.point.y,x=e.rightSE.point.y;if(n<i){if(u<o&&u<c)return 1;if(u>o&&u>c)return-1;const r=t.comparePoint(e.leftSE.point);if(r<0)return 1;if(r>0)return-1;const f=e.comparePoint(t.rightSE.point);return f!==0?f:-1}if(n>i){if(o<u&&o<x)return-1;if(o>u&&o>x)return 1;const r=e.comparePoint(t.leftSE.point);if(r!==0)return r;const f=t.comparePoint(e.rightSE.point);return f<0?1:f>0?-1:1}if(o<u)return-1;if(o>u)return 1;if(s<h){const r=e.comparePoint(t.rightSE.point);if(r!==0)return r}if(s>h){const r=t.comparePoint(e.rightSE.point);if(r<0)return 1;if(r>0)return-1}if(s!==h){const r=c-o,f=s-n,p=x-u,g=h-i;if(r>f&&p<g)return 1;if(r<f&&p>g)return-1}return s>h?1:s<h||c<x?-1:c>x?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,i){this.id=++U,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=i}static fromRing(t,e,n){let i,s,h;const o=a.comparePoints(t,e);if(o<0)i=t,s=e,h=1;else if(o>0)i=e,s=t,h=-1;else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);const u=new a(i,!0),c=new a(s,!1);return new S(u,c,[n],[h])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,i=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const s=(t.y-e.y)/i.y,h=e.x+s*i.x;if(t.x===h)return 0;const o=(t.x-e.x)/i.x,u=e.y+o*i.y;return t.y===u?0:t.y<u?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),i=P(e,n);if(i===null)return null;const s=this.leftSE.point,h=this.rightSE.point,o=t.leftSE.point,u=t.rightSE.point,c=w(e,o)&&this.comparePoint(o)===0,x=w(n,s)&&t.comparePoint(s)===0,r=w(e,u)&&this.comparePoint(u)===0,f=w(n,h)&&t.comparePoint(h)===0;if(x&&c)return f&&!r?h:!f&&r?u:null;if(x)return r&&s.x===u.x&&s.y===u.y?null:s;if(c)return f&&h.x===o.x&&h.y===o.y?null:o;if(f&&r)return null;if(f)return h;if(r)return u;const p=z(s,this.vector(),o,t.vector());return p===null||!w(i,p)?null:v.round(p.x,p.y)}split(t){const e=[],n=t.events!==void 0,i=new a(t,!0),s=new a(t,!1),h=this.rightSE;this.replaceRightSE(s),e.push(s),e.push(i);const o=new S(i,h,this.rings.slice(),this.windings.slice());return a.comparePoints(o.leftSE.point,o.rightSE.point)>0&&o.swapEvents(),a.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(i.checkForConsuming(),s.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const i=S.compare(e,n);if(i!==0){if(i>0){const s=e;e=n,n=s}if(e.prev===n){const s=e;e=n,n=s}for(let s=0,h=n.rings.length;s<h;s++){const o=n.rings[s],u=n.windings[s],c=e.rings.indexOf(o);c===-1?(e.rings.push(o),e.windings.push(u)):e.windings[c]+=u}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}beforeState(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else{const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}return this._beforeState}afterState(){if(this._afterState!==void 0)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,i=this._afterState.multiPolys;for(let o=0,u=this.rings.length;o<u;o++){const c=this.rings[o],x=this.windings[o],r=e.indexOf(c);r===-1?(e.push(c),n.push(x)):n[r]+=x}const s=[],h=[];for(let o=0,u=e.length;o<u;o++){if(n[o]===0)continue;const c=e[o],x=c.poly;if(h.indexOf(x)===-1)if(c.isExterior)s.push(x);else{h.indexOf(x)===-1&&h.push(x);const r=s.indexOf(c.poly);r!==-1&&s.splice(r,1)}}for(let o=0,u=s.length;o<u;o++){const c=s[o].multiPoly;i.indexOf(c)===-1&&i.push(c)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(this._isInResult!==void 0)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(E.type){case"union":{const n=t.length===0,i=e.length===0;this._isInResult=n!==i;break}case"intersection":{let n,i;t.length<e.length?(n=t.length,i=e.length):(n=e.length,i=t.length),this._isInResult=i===E.numMultiPolys&&n<i;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2===1;break}case"difference":{const n=i=>i.length===1&&i[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${E.type}`)}return this._isInResult}}class B{constructor(t,e,n){if(!Array.isArray(t)||t.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],typeof t[0][0]!="number"||typeof t[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const i=v.round(t[0][0],t[0][1]);this.bbox={ll:{x:i.x,y:i.y},ur:{x:i.x,y:i.y}};let s=i;for(let h=1,o=t.length;h<o;h++){if(typeof t[h][0]!="number"||typeof t[h][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let u=v.round(t[h][0],t[h][1]);u.x===s.x&&u.y===s.y||(this.segments.push(S.fromRing(s,u,this)),u.x<this.bbox.ll.x&&(this.bbox.ll.x=u.x),u.y<this.bbox.ll.y&&(this.bbox.ll.y=u.y),u.x>this.bbox.ur.x&&(this.bbox.ur.x=u.x),u.y>this.bbox.ur.y&&(this.bbox.ur.y=u.y),s=u)}(i.x!==s.x||i.y!==s.y)&&this.segments.push(S.fromRing(s,i,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const i=this.segments[e];t.push(i.leftSE),t.push(i.rightSE)}return t}}class X{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new B(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,i=t.length;n<i;n++){const s=new B(t[n],this,!1);s.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=s.bbox.ll.x),s.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=s.bbox.ll.y),s.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=s.bbox.ur.x),s.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=s.bbox.ur.y),this.interiorRings.push(s)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const i=this.interiorRings[e].getSweepEvents();for(let s=0,h=i.length;s<h;s++)t.push(i[s])}return t}}class ${constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof t[0][0][0]=="number"&&(t=[t])}catch{}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let n=0,i=t.length;n<i;n++){const s=new X(t[n],this);s.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=s.bbox.ll.x),s.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=s.bbox.ll.y),s.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=s.bbox.ur.x),s.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=s.bbox.ur.y),this.polys.push(s)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const i=this.polys[e].getSweepEvents();for(let s=0,h=i.length;s<h;s++)t.push(i[s])}return t}}class R{static factory(t){const e=[];for(let n=0,i=t.length;n<i;n++){const s=t[n];if(!s.isInResult()||s.ringOut)continue;let h=null,o=s.leftSE,u=s.rightSE;const c=[o],x=o.point,r=[];for(;h=o,o=u,c.push(o),o.point!==x;)for(;;){const f=o.getAvailableLinkedEvents();if(f.length===0){const y=c[0].point,d=c[c.length-1].point;throw new Error(`Unable to complete output ring starting at [${y.x}, ${y.y}]. Last matching segment found ends at [${d.x}, ${d.y}].`)}if(f.length===1){u=f[0].otherSE;break}let p=null;for(let y=0,d=r.length;y<d;y++)if(r[y].point===o.point){p=y;break}if(p!==null){const y=r.splice(p)[0],d=c.splice(y.index);d.unshift(d[0].otherSE),e.push(new R(d.reverse()));continue}r.push({index:c.length,point:o.point});const g=o.getLeftmostComparator(h);u=f.sort(g)[0].otherSE;break}e.push(new R(c))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let c=1,x=this.events.length-1;c<x;c++){const r=this.events[c].point,f=this.events[c+1].point;O(r,t,f)!==0&&(e.push(r),t=r)}if(e.length===1)return null;const n=e[0],i=e[1];O(n,t,i)===0&&e.shift(),e.push(e[0]);const s=this.isExteriorRing()?1:-1,h=this.isExteriorRing()?0:e.length-1,o=this.isExteriorRing()?e.length:-1,u=[];for(let c=h;c!=o;c+=s)u.push([e[c].x,e[c].y]);return u}isExteriorRing(){if(this._isExteriorRing===void 0){const t=this.enclosingRing();this._isExteriorRing=t?!t.isExteriorRing():!0}return this._isExteriorRing}enclosingRing(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let i=1,s=this.events.length;i<s;i++){const h=this.events[i];a.compare(t,h)>0&&(t=h)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class C{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(t[0]===null)return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const i=this.interiorRings[e].getGeom();i!==null&&t.push(i)}return t}}class V{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const i=this.polys[e].getGeom();i!==null&&t.push(i)}return t}_composePolys(t){const e=[];for(let n=0,i=t.length;n<i;n++){const s=t[n];if(!s.poly)if(s.isExteriorRing())e.push(new C(s));else{const h=s.enclosingRing();h.poly||e.push(new C(h)),h.poly.addInterior(s)}}return e}}class D{constructor(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:S.compare;this.queue=t,this.tree=new M(e),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const i=t.isLeft?this.tree.add(e):this.tree.find(e);if(!i)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let s=i,h=i,o,u;for(;o===void 0;)s=this.tree.prev(s),s===null?o=null:s.key.consumedBy===void 0&&(o=s.key);for(;u===void 0;)h=this.tree.next(h),h===null?u=null:h.key.consumedBy===void 0&&(u=h.key);if(t.isLeft){let c=null;if(o){const r=o.getIntersection(e);if(r!==null&&(e.isAnEndpoint(r)||(c=r),!o.isAnEndpoint(r))){const f=this._splitSafely(o,r);for(let p=0,g=f.length;p<g;p++)n.push(f[p])}}let x=null;if(u){const r=u.getIntersection(e);if(r!==null&&(e.isAnEndpoint(r)||(x=r),!u.isAnEndpoint(r))){const f=this._splitSafely(u,r);for(let p=0,g=f.length;p<g;p++)n.push(f[p])}}if(c!==null||x!==null){let r=null;c===null?r=x:x===null?r=c:r=a.comparePoints(c,x)<=0?c:x,this.queue.remove(e.rightSE),n.push(e.rightSE);const f=e.split(r);for(let p=0,g=f.length;p<g;p++)n.push(f[p])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=o)}else{if(o&&u){const c=o.getIntersection(u);if(c!==null){if(!o.isAnEndpoint(c)){const x=this._splitSafely(o,c);for(let r=0,f=x.length;r<f;r++)n.push(x[r])}if(!u.isAnEndpoint(c)){const x=this._splitSafely(u,c);for(let r=0,f=x.length;r<f;r++)n.push(x[r])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const i=t.split(e);return i.push(n),t.consumedBy===void 0&&this.tree.add(t),i}}const k=typeof process<"u"&&{}.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,Q=typeof process<"u"&&{}.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;class W{run(t,e,n){E.type=t,v.reset();const i=[new $(e,!0)];for(let r=0,f=n.length;r<f;r++)i.push(new $(n[r],!1));if(E.numMultiPolys=i.length,E.type==="difference"){const r=i[0];let f=1;for(;f<i.length;)P(i[f].bbox,r.bbox)!==null?f++:i.splice(f,1)}if(E.type==="intersection")for(let r=0,f=i.length;r<f;r++){const p=i[r];for(let g=r+1,y=i.length;g<y;g++)if(P(p.bbox,i[g].bbox)===null)return[]}const s=new M(a.compare);for(let r=0,f=i.length;r<f;r++){const p=i[r].getSweepEvents();for(let g=0,y=p.length;g<y;g++)if(s.insert(p[g]),s.size>k)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const h=new D(s);let o=s.size,u=s.pop();for(;u;){const r=u.key;if(s.size===o){const p=r.segment;throw new Error(`Unable to pop() ${r.isLeft?"left":"right"} SweepEvent [${r.point.x}, ${r.point.y}] from segment #${p.id} [${p.leftSE.point.x}, ${p.leftSE.point.y}] -> [${p.rightSE.point.x}, ${p.rightSE.point.y}] from queue.`)}if(s.size>k)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(h.segments.length>Q)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const f=h.process(r);for(let p=0,g=f.length;p<g;p++){const y=f[p];y.consumedBy===void 0&&s.insert(y)}o=s.size,u=s.pop()}v.reset();const c=R.factory(h.segments);return new V(c).getGeom()}}const E=new W,Z=function(l){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return E.run("union",l,e)},J=function(l){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return E.run("intersection",l,e)},H=function(l){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return E.run("xor",l,e)},K=function(l){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return E.run("difference",l,e)};var nt={union:Z,intersection:J,xor:H,difference:K};export{nt as i};
