function C(t,e,i={}){const r={type:"Feature"};return(i.id===0||i.id)&&(r.id=i.id),i.bbox&&(r.bbox=i.bbox),r.properties=e||{},r.geometry=t,r}function G(t,e,i={}){if(!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!v(t[0])||!v(t[1]))throw new Error("coordinates must contain numbers");return C({type:"Point",coordinates:t},e,i)}function v(t){return!isNaN(t)&&t!==null&&!Array.isArray(t)}function E(t,e,i){if(t!==null)for(var r,o,a,h,P,n,y,b=0,l=0,w,M=t.type,S=M==="FeatureCollection",k=M==="Feature",A=S?t.features.length:1,c=0;c<A;c++){y=S?t.features[c].geometry:k?t.geometry:t,w=y?y.type==="GeometryCollection":!1,P=w?y.geometries.length:1;for(var g=0;g<P;g++){var f=0,u=0;if(h=w?y.geometries[g]:y,h!==null){n=h.coordinates;var s=h.type;switch(b=i&&(s==="Polygon"||s==="MultiPolygon")?1:0,s){case null:break;case"Point":if(e(n,l,c,f,u)===!1)return!1;l++,f++;break;case"LineString":case"MultiPoint":for(r=0;r<n.length;r++){if(e(n[r],l,c,f,u)===!1)return!1;l++,s==="MultiPoint"&&f++}s==="LineString"&&f++;break;case"Polygon":case"MultiLineString":for(r=0;r<n.length;r++){for(o=0;o<n[r].length-b;o++){if(e(n[r][o],l,c,f,u)===!1)return!1;l++}s==="MultiLineString"&&f++,s==="Polygon"&&u++}s==="Polygon"&&f++;break;case"MultiPolygon":for(r=0;r<n.length;r++){for(u=0,o=0;o<n[r].length;o++){for(a=0;a<n[r][o].length-b;a++){if(e(n[r][o][a],l,c,f,u)===!1)return!1;l++}u++}f++}break;case"GeometryCollection":for(r=0;r<h.geometries.length;r++)if(E(h.geometries[r],e,i)===!1)return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function p(t,e={}){let i=0,r=0,o=0;return E(t,function(a){i+=a[0],r+=a[1],o++},!0),G([i/o,r/o],e.properties)}export{p as c};
